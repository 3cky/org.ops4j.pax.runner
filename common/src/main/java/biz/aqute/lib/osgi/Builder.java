package biz.aqute.lib.osgi;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * Bundle-Includes: ( [name '=' ] file )+
 *
 * Private-Package: package-decl ( ',' package-decl )*
 *
 * Export-Package: package-decl ( ',' package-decl )*
 *
 * Import-Package: package-decl ( ',' package-decl )*
 *
 * @version $Revision$
 */
public class Builder extends Analyzer
{

    boolean sources = false;
    private File[] sourcePath;

    public void setProperties( Properties properties )
    {
        super.setProperties( properties );
    }

    public Jar build()
        throws Exception
    {
        sources = getProperty( "-sources" ) != null;
        Jar dot = getDot();
        dot = new Jar( "dot" );
        doIncludes( dot );
        doExpand( dot );
        dot.setManifest( calcManifest() );
        // This must happen after we analyzed so
        // we know what it is on the classpath
        addSources( dot );
        doVerify( dot );
        if( dot.getResources().isEmpty() )
        {
            error( "No Resources Found" );
        }
        return dot;
    }

    /**
     *
     * @param dot
     */
    private void addSources( Jar dot )
    {
        if( !sources )
        {
            return;
        }

        try
        {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            getProperties().store( out, "Generated by BND, at " + new Date() );
            EmbeddedResource resource = new EmbeddedResource( out.toByteArray() );
            dot.putResource( "OSGI-OPT/bnd.bnd", resource );
        }
        catch( IOException e )
        {
            error( "Can not embed bnd file in JAR: " + e );
        }

        Map<String, Clazz> classspace = getClassSpace();
        for( Iterator cpe = classspace.keySet().iterator(); cpe.hasNext(); )
        {
            String path = (String) cpe.next();
            path = path.replace( ".class", ".java" );

            for( int i = 0; i < sourcePath.length; i++ )
            {
                File root = sourcePath[ i ];
                File f = new File( root, path );
                if( f.exists() )
                {
                    dot.putResource( "OSGI-OPT/src/" + path, new FileResource( f ) );
                }
            }
        }
    }

    private void doVerify( Jar dot )
        throws Exception
    {
        Verifier verifier = new Verifier( dot );
        verifier.verify();
        errors.addAll( verifier.getErrors() );
        warnings.addAll( verifier.getWarnings() );
    }

    private void doExpand( Jar jar )
        throws IOException
    {
        Map headerPrivate = getHeader( Analyzer.PRIVATE_PACKAGE );
        Map included = replaceWithPattern( headerPrivate );
        Map headerExport = getHeader( Analyzer.EXPORT_PACKAGE );
        included.putAll( replaceWithPattern( headerExport ) );
        if( included.isEmpty() )
        {
            warnings.add( "Neither Export-Package nor Private-Package is set, therefore no packages will be included" );
        }
        Set superfluous = new HashSet( included.keySet() );

        List<Jar> classpath = getClasspath();
        for( Iterator c = classpath.iterator(); c.hasNext(); )
        {
            Jar now = (Jar) c.next();
            doExpand( jar, included, now, superfluous );
        }
        if( superfluous.size() > 0 )
        {
            warning( "Instructions that are never used: " + superfluous );
        }
    }

    /**
     * Iterate over each directory in the class path entry and check if that
     * directory is a desired package.
     *
     * @param included
     * @param classpathEntry
     * @param jar
     * @param jar
     * @param superfluous
     */
    private void doExpand( Jar jar, Map included, Jar classpathEntry, Set superfluous )
    {
        Map<String, Map<String, Resource>> directories = classpathEntry.getDirectories();
        Iterator p = directories.entrySet().iterator();
        for( Map.Entry<String, Map<String, Resource>> directory : directories.entrySet() )
        {
            String path = directory.getKey();
            if( doNotCopy.matcher( getName( path ) ).matches() )
            {
                continue;
            }
            String pack = path.replace( '/', '.' );
            if( matches( included, pack, superfluous ) != null )
            {
                Map contents = (Map) directory.getValue();
                jar.addDirectory( contents );
            }
        }
    }

    private Map replaceWithPattern( Map header )
    {
        Map map = new LinkedHashMap();
        for( Iterator e = header.entrySet().iterator(); e.hasNext(); )
        {
            Map.Entry entry = (Map.Entry) e.next();
            Pattern p = Analyzer.getPattern( (String) entry.getKey() );
            map.put( p, entry.getValue() );
        }
        return map;
    }

    private Map matches( Map instructions, String pack, Set superfluousPatterns )
    {
        for( Iterator i = instructions.keySet().iterator(); i.hasNext(); )
        {
            Pattern pattern = (Pattern) i.next();
            if( pattern.matcher( pack ).matches() )
            {
                superfluousPatterns.remove( pattern );
                return (Map) instructions.get( pattern );
            }
        }
        return null;
    }

    private Map getHeader( String string )
    {
        if( string == null )
        {
            return new LinkedHashMap();
        }
        return parseHeader( getProperty( string ) );
    }

    /**
     * Parse the Bundle-Includes header. Files in the bundles Include header are
     * included in the jar. The source can be a directory or a file.
     * @param jar the Jar to process.
     * @throws java.io.IOException  if an IO problem occurs.
     */
    private void doIncludes( Jar jar )
        throws IOException
    {
        String includes = getProperty( "Bundle-Includes" );
        if( includes == null )
        {
            return;
        }

        String[] clauses = includes.split( "\\s*,\\s*" );
        for( int i = 0; i < clauses.length; i++ )
        {
            File base = getBase();
            if( clauses[ i ].startsWith( "@" ) )
            {
                ZipResource.build( jar, new File( base, clauses[ i ].substring( 1 ) ) );
            }
            else
            {
                String[] clause = clauses[ i ].split( "\\s*=\\s*" );
                if( clause.length == 1 )
                {
                    String path = getName( clause[ 0 ].trim() );
                    copy( jar, path, new File( base, clause[ 0 ].trim() ) );
                }
                else
                {
                    copy( jar, clause[ 0 ].trim(), new File( clause[ 1 ].trim() ) );
                }
            }
        }
    }

    private void copy( Jar jar, String path, File from )
        throws IOException
    {
        if( doNotCopy.matcher( from.getName() ).matches() )
        {
            return;
        }

        if( from.isDirectory() )
        {
            String next = path;
            if( next.length() != 0 )
            {
                next += '/';
            }

            File[] files = from.listFiles();
            for( int i = 0; i < files.length; i++ )
            {
                copy( jar, next + files[ i ].getName(), files[ i ] );
            }
        }
        else
        {
            jar.putResource( path, new FileResource( from ) );
        }

    }

    private String getName( String where )
    {
        int n = where.lastIndexOf( '/' );
        if( n < 0 )
        {
            return where;
        }

        return where.substring( n + 1 );
    }

    public void setSourcepath( File[] files )
    {
        sourcePath = files;
	}

}
